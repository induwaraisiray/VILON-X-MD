const axios = require("axios");
const FormData = require("form-data");
const fs = require("fs");
const os = require("os");
const path = require("path");
const translate = require('@vitalets/google-translate-api'); // stable free version
const config = require("../config");
const { cmd, commands } = require("../command");

// COUNTRY INFO
cmd({
  pattern: "countryinfo",
  alias: ["cinfo", "country", "cinfo2"],
  desc: "Get information about a country",
  category: "info",
  react: "üåç",
  filename: __filename
}, async (conn, mek, m, { from, q, reply, react }) => {
  try {
    if (!q) return reply("Please provide a country name.\nExample: `.countryinfo Pakistan`");

    const apiUrl = `https://api.siputzx.my.id/api/tools/countryInfo?name=${encodeURIComponent(q)}`;
    const { data } = await axios.get(apiUrl);

    if (!data.status || !data.data) {
      await react("‚ùå");
      return reply(`No information found for *${q}*. Please check the country name.`);
    }

    const info = data.data;
    let neighborsText = info.neighbors.length > 0
      ? info.neighbors.map(n => `üåç *${n.name}*`).join(", ")
      : "No neighboring countries found.";

    const text = `üåç *Country Information: ${info.name}* üåç\n\n` +
      `üèõ *Capital:* ${info.capital}\n` +
      `üìç *Continent:* ${info.continent.name} ${info.continent.emoji}\n` +
      `üìû *Phone Code:* ${info.phoneCode}\n` +
      `üìè *Area:* ${info.area.squareKilometers} km¬≤ (${info.area.squareMiles} mi¬≤)\n` +
      `üöó *Driving Side:* ${info.drivingSide}\n` +
      `üí± *Currency:* ${info.currency}\n` +
      `üî§ *Languages:* ${info.languages.native.join(", ")}\n` +
      `üåü *Famous For:* ${info.famousFor}\n` +
      `üåç *ISO Codes:* ${info.isoCode.alpha2.toUpperCase()}, ${info.isoCode.alpha3.toUpperCase()}\n` +
      `üåé *Internet TLD:* ${info.internetTLD}\n\n` +
      `üîó *Neighbors:* ${neighborsText}`;

    await conn.sendMessage(from, {
      image: { url: info.flag },
      caption: text,
      contextInfo: { mentionedJid: [m.sender] }
    }, { quoted: mek });

    await react("‚úÖ");
  } catch (e) {
    console.error("Error in countryinfo command:", e);
    await react("‚ùå");
    reply("An error occurred while fetching country information.");
  }
});

// MSG

cmd({
  pattern: "msg",
  desc: "Send a message multiple times (Owner Only)",
  category: "utility",
  react: "üëæ",
  filename: __filename
},
async (conn, mek, m, {
  from,
  reply,
  isCreator,
  q
}) => {
  // Owner-only restriction
  if (!isCreator) return reply('üö´ *Owner only command!*');

  try {
    // Check format: .msg text,count
    if (!q.includes(',')) {
      return reply("‚ùå *Format:* .msg text,count\n*Example:* .msg Hello,5");
    }

    const [message, countStr] = q.split(',');
    const count = parseInt(countStr.trim());

    // Hard limit: 1-100 messages
    if (isNaN(count) || count < 1 || count > 1000) {
      // Fixed the error message to be more accurate
      return reply("‚ùå *Message count must be between 1 and 1000.*");
    }

    // Silent execution (no confirmations)
    for (let i = 0; i < count; i++) {
      await conn.sendMessage(from, {
        text: message
      }, {
        quoted: null
      });
      if (i < count - 1) await new Promise(resolve => setTimeout(resolve, 100)); // 500ms delay
    }

  } catch (e) {
    console.error("Error in msg command:", e);
    reply(`‚ùå *Error:* ${e.message}`);
  }
});

//temp mail


cmd({
  pattern: "tempmail",
  alias: ["genmail"],
  desc: "Generate a new temporary email address",
  category: "utility",
  react: "üìß",
  filename: __filename
},
async (conn, mek, m, {
  from,
  reply,
  prefix
}) => {
  try {
    const response = await axios.get('https://apis.davidcyriltech.my.id/temp-mail');
    const {
      email,
      session_id,
      expires_at
    } = response.data;

    // Format the expiration time and date
    const expiresDate = new Date(expires_at);
    const timeString = expiresDate.toLocaleTimeString('en-US', {
      hour: '2-digit',
      minute: '2-digit',
      hour12: true
    });
    const dateString = expiresDate.toLocaleDateString('en-US', {
      weekday: 'short',
      month: 'short',
      day: 'numeric',
      year: 'numeric'
    });

    // Create the complete message
    const message = `
üìß *TEMPORARY EMAIL GENERATED*

‚úâÔ∏è *Email Address:*
${email}

‚è≥ *Expires:*
${timeString} ‚Ä¢ ${dateString}

üîë *Session ID:*
\`\`\`${session_id}\`\`\`

üì• *Check Inbox:*
.inbox ${session_id}

_Email will expire after 24 hours_
`;

    await conn.sendMessage(
      from, {
        text: message,
        contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          forwardedNewsletterMessageInfo: {
            newsletterJid: '120363363023106228@newsletter',
            newsletterName: 'TempMail Service',
            serverMessageId: 101
          }
        }
      }, {
        quoted: mek
      }
    );

  } catch (e) {
    console.error('TempMail error:', e);
    reply(`‚ùå Error: ${e.message}`);
  }
});
cmd({
  pattern: "checkmail",
  alias: ["inbox", "tmail", "mailinbox"],
  desc: "Check your temporary email inbox",
  category: "utility",
  react: "üì¨",
  filename: __filename
},
async (conn, mek, m, {
  from,
  reply,
  args
}) => {
  try {
    const sessionId = args[0];
    if (!sessionId) return reply('üîë Please provide your session ID\nExample: .checkmail YOUR_SESSION_ID');

    const inboxUrl = `https://apis.davidcyriltech.my.id/temp-mail/inbox?id=${encodeURIComponent(sessionId)}`;
    const response = await axios.get(inboxUrl);

    if (!response.data.success) {
      return reply('‚ùå Invalid session ID or expired email');
    }

    const {
      inbox_count,
      messages
    } = response.data;

    if (inbox_count === 0) {
      return reply('üì≠ Your inbox is empty');
    }

    let messageList = `üì¨ *You have ${inbox_count} message(s)*\n\n`;
    messages.forEach((msg, index) => {
      messageList += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
        `üìå *Message ${index + 1}*\n` +
        `üë§ *From:* ${msg.from}\n` +
        `üìù *Subject:* ${msg.subject}\n` +
        `‚è∞ *Date:* ${new Date(msg.date).toLocaleString()}\n\n` +
        `üìÑ *Content:*\n${msg.body}\n\n`;
    });

    await reply(messageList);

  } catch (e) {
    console.error('CheckMail error:', e);
    reply(`‚ùå Error checking inbox: ${e.response?.data?.message || e.message}`);
  }
});

cmd({
    pattern: "weather",
    desc: "üå§ Get weather information for a location",
    react: "üå§",
    category: "other",
    filename: __filename
},
async (conn, mek, m, { from, q, reply }) => {
    try {
        if (!q) return reply("‚ùó Please provide a city name. Usage: .weather [city name]");
        const apiKey = '2d61a72574c11c4f36173b627f8cb177'; 
        const city = q;
        const url = `http://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${apiKey}&units=metric`;
        const response = await axios.get(url);
        const data = response.data;
        const weather = `
üåç *Weather Information for ${data.name}, ${data.sys.country}* üåç
üå°Ô∏è *Temperature*: ${data.main.temp}¬∞C
üå°Ô∏è *Feels Like*: ${data.main.feels_like}¬∞C
üå°Ô∏è *Min Temp*: ${data.main.temp_min}¬∞C
üå°Ô∏è *Max Temp*: ${data.main.temp_max}¬∞C
üíß *Humidity*: ${data.main.humidity}%
‚òÅÔ∏è *Weather*: ${data.weather[0].main}
üå´Ô∏è *Description*: ${data.weather[0].description}
üí® *Wind Speed*: ${data.wind.speed} m/s
üîΩ *Pressure*: ${data.main.pressure} hPa

> *¬© ·¥©·¥è·¥°·¥á Ä·¥Ö  ô è ·¥†…™ ü·¥è…¥-x-·¥ç·¥Ö*
`;
        return reply(weather);
    } catch (e) {
        console.log(e);
        if (e.response && e.response.status === 404) {
            return reply("üö´ City not found. Please check the spelling and try again.");
        }
        return reply("‚ö†Ô∏è An error occurred while fetching the weather information. Please try again later.");
    }
});

cmd({
    pattern: "trsi",
    desc: "Translate English ‚Üí Sinhala (reply to a message)",
    category: "tools",
    react: "üåê",
    filename: __filename
}, async (conn, mek, m, { reply, react }) => {
    const msg = m.quoted?.text;
    if (!msg) return reply("‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª reply message ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂Ø‡∑ô‡∂±‡∑ä‡∂±.");

    try {
        const res = await translate(msg, { to: 'si' });
        await react("‚úÖ");
        return reply(`üá±üá∞ *‡∑É‡∑í‡∂Ç‡∑Ñ‡∂Ω‡∂ß ‡∂¥‡∂ª‡∑í‡∑Ä‡∂ª‡∑ä‡∂≠‡∂±‡∂∫:* \n\n${res.text}`);
    } catch (e) {
        console.error("Translate Error:", e);
        await react("‚ùå");
        return reply("‡∂¥‡∂ª‡∑í‡∑Ä‡∂ª‡∑ä‡∂≠‡∂±‡∂∫ ‡∂Ö‡∑É‡∑è‡∂ª‡∑ä‡∂Æ‡∂ö‡∂∫‡∑í.");
    }
});

// Sinhala ‚ûú English
cmd({
    pattern: "tren",
    desc: "Translate Sinhala ‚Üí English (reply to a message)",
    category: "tools",
    react: "üåê",
    filename: __filename
}, async (conn, mek, m, { reply, react }) => {
    const msg = m.quoted?.text;
    if (!msg) return reply("Please reply to a Sinhala message to translate.");

    try {
        const res = await translate(msg, { to: 'en' });
        await react("‚úÖ");
        return reply(`üá¨üáß *Translated to English:* \n\n${res.text}`);
    } catch (e) {
        console.error("Translate Error:", e);
        await react("‚ùå");
        return reply("Translation failed.");
    }
});


cmd({
    pattern: "tts",
    desc: "Convert Sinhala text to speech",
    react: "üó£Ô∏è",
    filename: __filename
}, async (conn, m, msg, { text, from }) => {
    if (!text) {
        return await conn.sendMessage(from, { text: "‡∂ã‡∂Ø‡∑è‡∑Ñ‡∂ª‡∂´‡∂∫‡∂ö‡∑ä: `.tts ‡∂î‡∂∫‡∑è‡∂ß ‡∂ö‡∑ú‡∑Ñ‡∑ú‡∂∏‡∂Ø ‡∂ö‡∑í‡∂∫‡∂Ω‡∑è`" });
    }

    try {
        const ttsRes = await axios({
            method: "GET",
            url: `https://translate.google.com/translate_tts`,
            params: {
                ie: "UTF-8",
                q: text,
                tl: "si",
                client: "tw-ob"
            },
            responseType: "arraybuffer"
        });

        const filePath = path.join(__dirname, '../temp', `${Date.now()}.mp3`);
        fs.writeFileSync(filePath, ttsRes.data);

        await conn.sendMessage(from, {
            audio: fs.readFileSync(filePath),
            mimetype: 'audio/mp4',
            ptt: true
        });

        fs.unlinkSync(filePath);
    } catch (err) {
        console.error("TTS Error:", err);
        await conn.sendMessage(from, { text: "‡∑Ä‡∂Ø‡∑í‡∂±‡∑Ä‡∑è! TTS voice ‡∂ë‡∂ö generate ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∂∂‡∑ê‡∂ª‡∑í ‡∑Ä‡∑î‡∂´‡∑è." });
    }
});


cmd({
    pattern: "person",
    react: "üë§",
    alias: ["userinfo", "profile"],
    desc: "Get complete user profile information",
    category: "utility",
    use: '.person [@tag or reply]',
    filename: __filename
},
async (conn, mek, m, { from, sender, isGroup, reply, quoted, participants }) => {
    try {
        // 1. DETERMINE TARGET USER
        let userJid = quoted?.sender || 
                     mek.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0] || 
                     sender;

        // 2. VERIFY USER EXISTS
        const [user] = await conn.onWhatsApp(userJid).catch(() => []);
        if (!user?.exists) return reply("‚ùå User not found on WhatsApp");

        // 3. GET PROFILE PICTURE
        let ppUrl;
        try {
            ppUrl = await conn.profilePictureUrl(userJid, 'image');
        } catch {
            ppUrl = 'https://i.ibb.co/KhYC4FY/1221bc0bdd2354b42b293317ff2adbcf-icon.png';
        }

        // 4. GET NAME (MULTI-SOURCE FALLBACK)
        let userName = userJid.split('@')[0];
        try {
            // Try group participant info first
            if (isGroup) {
                const member = participants.find(p => p.id === userJid);
                if (member?.notify) userName = member.notify;
            }
            
            // Try contact DB
            if (userName === userJid.split('@')[0] && conn.contactDB) {
                const contact = await conn.contactDB.get(userJid).catch(() => null);
                if (contact?.name) userName = contact.name;
            }
            
            // Try presence as final fallback
            if (userName === userJid.split('@')[0]) {
                const presence = await conn.presenceSubscribe(userJid).catch(() => null);
                if (presence?.pushname) userName = presence.pushname;
            }
        } catch (e) {
            console.log("Name fetch error:", e);
        }

        // 5. GET BIO/ABOUT
        let bio = {};
        try {
            // Try personal status
            const statusData = await conn.fetchStatus(userJid).catch(() => null);
            if (statusData?.status) {
                bio = {
                    text: statusData.status,
                    type: "Personal",
                    updated: statusData.setAt ? new Date(statusData.setAt * 1000) : null
                };
            } else {
                // Try business profile
                const businessProfile = await conn.getBusinessProfile(userJid).catch(() => null);
                if (businessProfile?.description) {
                    bio = {
                        text: businessProfile.description,
                        type: "Business",
                        updated: null
                    };
                }
            }
        } catch (e) {
            console.log("Bio fetch error:", e);
        }

        // 6. GET GROUP ROLE
        let groupRole = "";
        if (isGroup) {
            const participant = participants.find(p => p.id === userJid);
            groupRole = participant?.admin ? "üëë Admin" : "üë• Member";
        }

        // 7. FORMAT OUTPUT
        const formattedBio = bio.text ? 
            `${bio.text}\n‚îî‚îÄ üìå ${bio.type} Bio${bio.updated ? ` | üïí ${bio.updated.toLocaleString()}` : ''}` : 
            "No bio available";

        const userInfo = `
*GC MEMBER INFORMATION üßä*

üìõ *Name:* ${userName}
üî¢ *Number:* ${userJid.replace(/@.+/, '')}
üìå *Account Type:* ${user.isBusiness ? "üíº Business" : user.isEnterprise ? "üè¢ Enterprise" : "üë§ Personal"}

*üìù About:*
${formattedBio}

*‚öôÔ∏è Account Info:*
‚úÖ Registered: ${user.isUser ? "Yes" : "No"}
üõ°Ô∏è Verified: ${user.verifiedName ? "‚úÖ Verified" : "‚ùå Not verified"}
${isGroup ? `üë• *Group Role:* ${groupRole}` : ''}
`.trim();

        // 8. SEND RESULT
        await conn.sendMessage(from, {
            image: { url: ppUrl },
            caption: userInfo,
            mentions: [userJid]
        }, { quoted: mek });

    } catch (e) {
        console.error("Person command error:", e);
        reply(`‚ùå Error: ${e.message || "Failed to fetch profile"}`);
    }
});

cmd({
    pattern: "tempnum",
    alias: ["fakenum", "tempnumber"],
    desc: "Get temporary numbers & OTP instructions",
    category: "tools",
    react: "üì±",
    use: "<country-code>"
},
async (conn, mek, m, { from, args, reply }) => {
    try {
        // Mandatory country code check
        if (!args || args.length < 1) {
            return reply(`‚ùå *Usage:* .tempnum <country-code>\nExample: .tempnum us\n\nüì¶ Use .otpbox <number>* to check OTPs`);
        }

        const countryCode = args[0].toLowerCase();
        
        // API call with validation
        const { data } = await axios.get(
            `https://api.vreden.my.id/api/tools/fakenumber/listnumber?id=${countryCode}`,
            { 
                timeout: 10000,
                validateStatus: status => status === 200
            }
        );

        // Fixed syntax error here - added missing parenthesis
        if (!data?.result || !Array.isArray(data.result)) {
            console.error("Invalid API structure:", data);
            return reply(`‚ö† Invalid API response format\nTry .tempnum us`);
        }

        if (data.result.length === 0) {
            return reply(`üì≠ No numbers available for *${countryCode.toUpperCase()}*\nTry another country code!\n\nUse .otpbox <number> after selection`);
        }

        // Process numbers
        const numbers = data.result.slice(0, 25);
        const numberList = numbers.map((num, i) => 
            `${String(i+1).padStart(2, ' ')}. ${num.number}`
        ).join("\n");

        // Final message with OTP instructions
        await reply(
            `‚ï≠‚îÄ‚îÄ„Äå üì± TEMPORARY NUMBERS „Äç\n` +
            `‚îÇ\n` +
            `‚îÇ Country: ${countryCode.toUpperCase()}\n` +
            `‚îÇ Numbers Found: ${numbers.length}\n` +
            `‚îÇ\n` +
            `${numberList}\n\n` +
            `‚ï∞‚îÄ‚îÄ„Äå üì¶ USE: .otpbox <number> „Äç\n` +
            `_Example: .otpbox +1234567890_`
        );

    } catch (err) {
        console.error("API Error:", err);
        const errorMessage = err.code === "ECONNABORTED" ? 
            `‚è≥ *Timeout*: API took too long\nTry smaller country codes like 'us', 'gb'` :
            `‚ö† *Error*: ${err.message}\nUse format: .tempnum <country-code>`;
            
        reply(`${errorMessage}\n\nüîë Remember: ${prefix}otpinbox <number>`);
    }
});

cmd({
    pattern: "templist",
    alias: ["tempnumberlist", "tempnlist", "listnumbers"],
    desc: "Show list of countries with temp numbers",
    category: "tools",
    react: "üåç",
    filename: __filename,
    use: ".templist"
},
async (conn, m, { reply }) => {
    try {
        const { data } = await axios.get("https://api.vreden.my.id/api/tools/fakenumber/country");

        if (!data || !data.result) return reply("‚ùå Couldn't fetch country list.");

        const countries = data.result.map((c, i) => `*${i + 1}.* ${c.title} \`(${c.id})\``).join("\n");

        await reply(`üåç *Total Available Countries:* ${data.result.length}\n\n${countries}`);
    } catch (e) {
        console.error("TEMP LIST ERROR:", e);
        reply("‚ùå Failed to fetch temporary number country list.");
    }
});

cmd({
    pattern: "otpbox",
    alias: ["checkotp", "getotp"],
    desc: "Check OTP messages for temporary number",
    category: "tools",
    react: "üîë",
    use: "<full-number>"
},
async (conn, mek, m, { from, args, reply }) => {
    try {
        // Validate input
        if (!args[0] || !args[0].startsWith("+")) {
            return reply(`‚ùå *Usage:* .otpbox <full-number>\nExample: .otpbox +9231034481xx`);
        }

        const phoneNumber = args[0].trim();
        
        // Fetch OTP messages
        const { data } = await axios.get(
            `https://api.vreden.my.id/api/tools/fakenumber/message?nomor=${encodeURIComponent(phoneNumber)}`,
            { 
                timeout: 10000,
                validateStatus: status => status === 200
            }
        );

        // Validate response
        if (!data?.result || !Array.isArray(data.result)) {
            return reply("‚ö† No OTP messages found for this number");
        }

        // Format OTP messages
        const otpMessages = data.result.map(msg => {
            // Extract OTP code (matches common OTP patterns)
            const otpMatch = msg.content.match(/\b\d{4,8}\b/g);
            const otpCode = otpMatch ? otpMatch[0] : "Not found";
            
            return `‚îå *From:* ${msg.from || "Unknown"}
‚îÇ *Code:* ${otpCode}
‚îÇ *Time:* ${msg.time_wib || msg.timestamp}
‚îî *Message:* ${msg.content.substring(0, 50)}${msg.content.length > 50 ? "..." : ""}`;
        }).join("\n\n");

        await reply(
            `‚ï≠‚îÄ‚îÄ„Äå üîë OTP MESSAGES „Äç\n` +
            `‚îÇ Number: ${phoneNumber}\n` +
            `‚îÇ Messages Found: ${data.result.length}\n` +
            `‚îÇ\n` +
            `${otpMessages}\n` +
            `‚ï∞‚îÄ‚îÄ„Äå üìå Use .tempnum to get numbers „Äç`
        );

    } catch (err) {
        console.error("OTP Check Error:", err);
        const errorMsg = err.code === "ECONNABORTED" ?
            "‚åõ OTP check timed out. Try again later" :
            `‚ö† Error: ${err.response?.data?.error || err.message}`;
        
        reply(`${errorMsg}\n\nUsage: .otpbox +9231034481xx`);
    }
});


cmd({
    pattern: "get",
    alias: ["source", "js"],
    desc: "Fetch the full source code of a command",
    category: "owner",
    react: "üìú",
    filename: __filename
},
async (conn, mek, m, { from, args, reply, isOwner }) => {
    try {
        if (!isOwner) return reply("‚ùå You don't have permission to use this command!");
        if (!args[0]) return reply("‚ùå Please provide a command name. Example: `.get alive`");

        const commandName = args[0].toLowerCase();
        const commandData = commands.find(cmd => cmd.pattern === commandName || (cmd.alias && cmd.alias.includes(commandName)));

        if (!commandData) return reply("‚ùå Command not found!");

        // Get the command file path
        const commandPath = commandData.filename;

        // Read the full source code
        const fullCode = fs.readFileSync(commandPath, 'utf-8');

        // Truncate long messages for WhatsApp
        let truncatedCode = fullCode;
        if (truncatedCode.length > 4000) {
            truncatedCode = fullCode.substring(0, 4000) + "\n\n// Code too long, sending full file üìÇ";
        }

        // Formatted caption with truncated code
        const formattedCode = `‚¨§‚îÄ‚îÄ‚îÄ„Äî *üìú Command Source* „Äï‚îÄ‚îÄ‚îÄ‚¨§
\`\`\`js
${truncatedCode}
\`\`\`
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ä∑  
*‚ö° Full file sent below üìÇ*  
> Powered By *ùöÖùô∏ùôªùôæùôΩ-ùöá-ùôºùô≥*`;

        // Send image with truncated source code
        await conn.sendMessage(from, { 
            image: { url: `https://files.catbox.moe/rexuf8.jpg` },  // Image URL
            caption: formattedCode,
            contextInfo: {
                mentionedJid: [m.sender],
                forwardingScore: 999,
                isForwarded: true,
                forwardedNewsletterMessageInfo: {
                    newsletterJid: '120363420933039839@newsletter',
                    newsletterName: 'ùöÖùô∏ùôªùôæùôΩ-ùöá-ùôºùô≥',
                    serverMessageId: 143
                }
            }
        }, { quoted: mek });

        // Send full source file
        const fileName = `${commandName}.js`;
        const tempPath = path.join(__dirname, fileName);
        fs.writeFileSync(tempPath, fullCode);

        await conn.sendMessage(from, { 
            document: fs.readFileSync(tempPath),
            mimetype: 'text/javascript',
            fileName: fileName
        }, { quoted: mek });

        // Delete the temporary file
        fs.unlinkSync(tempPath);

    } catch (e) {
        console.error("Error in .get command:", e);
        reply(`‚ùå Error: ${e.message}`);
    }
});
